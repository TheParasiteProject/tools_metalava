/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Copied from tools/base/layoutlib-api
package com.android.resources

import com.android.SdkConstants
import com.google.common.base.MoreObjects
import com.google.common.base.Strings
import com.google.common.collect.ImmutableMap
import com.google.common.collect.ImmutableSet
import com.google.common.collect.Sets
import java.util.Arrays
import java.util.function.BiFunction
import java.util.function.Function
import org.w3c.dom.Element
import org.w3c.dom.Node

/**
 * Enum representing a type of compiled resource.
 *
 * See `ResourceType` in aapt2/Resource.h.
 */
enum class ResourceType {
    ANIM("anim", "Animation"),
    ANIMATOR("animator", "Animator"),
    ARRAY("array", "Array", "string-array", "integer-array"),
    ATTR("attr", "Attr"),
    BOOL("bool", "Boolean"),
    COLOR("color", "Color"),
    DIMEN("dimen", "Dimension"),
    DRAWABLE("drawable", "Drawable"),
    FONT("font", "Font"),
    FRACTION("fraction", "Fraction"),
    ID("id", "ID"),
    INTEGER("integer", "Integer"),
    INTERPOLATOR("interpolator", "Interpolator"),
    LAYOUT("layout", "Layout"),
    MENU("menu", "Menu"),
    MIPMAP("mipmap", "Mip Map"),
    NAVIGATION("navigation", "Navigation"),
    PLURALS("plurals", "Plurals"),
    RAW("raw", "Raw"),
    STRING("string", "String"),
    STYLE("style", "Style"),
    STYLEABLE("styleable", "Styleable", Kind.STYLEABLE),
    TRANSITION("transition", "Transition"),
    XML("xml", "XML"),

    /**
     * This is not actually used. Only there because they get parsed and since we want to detect new
     * resource type, we need to have this one exist.
     */
    PUBLIC("public", "Public visibility modifier", Kind.SYNTHETIC),

    /**
     * This type is used for elements dynamically generated by the parsing of aapt:attr nodes. The
     * "aapt:attr" allow to inline resources as part of a different resource, for example, a
     * drawable as part of a layout. When the parser, encounters one of this nodes, it will generate
     * a synthetic _aaptattr reference.
     */
    AAPT("_aapt", "Aapt Attribute", Kind.SYNTHETIC),

    /**
     * This tag is used for marking a resource overlayable, i.e. that it can be overlaid at runtime
     * by RROs (Runtime Resource Overlays). This is a new feature supported starting Android 10.
     * This tag (and the content following it in that node) does not define a resource.
     */
    OVERLAYABLE("overlayable", "Overlayable tag", Kind.SYNTHETIC),

    /** Represents item tags inside a style definition. */
    STYLE_ITEM("item", "Style Item", Kind.SYNTHETIC),

    /**
     * Not an actual resource type from AAPT. Used to provide sample data values in the tools
     * namespace
     */
    SAMPLE_DATA("sample", "Sample data", Kind.SYNTHETIC),

    /**
     * Not a real resource, but a way of defining a resource reference that will be replaced with
     * its actual value during linking. Does not exist at runtime, nor does it appear in the R
     * class. Only present in raw and flat resources.
     */
    MACRO("macro", "Macro resource replacement", Kind.SYNTHETIC);

    private enum class Kind {
        /** These types are used both in the R and as XML tag names. */
        REAL,

        /**
         * Styleables are handled by aapt but don't end up in the resource table. They have an R
         * inner class (called `styleable`), are declared in XML (using `declare-styleable`) but
         * cannot be referenced from XML.
         */
        STYLEABLE,

        /**
         * Other types that are not known to aapt, but are used by tools to represent some
         * information in the resources system.
         */
        SYNTHETIC
    }

    /** Returns the resource type name, as used by XML files. */
    val xmlName: String
    private val mKind: Kind

    /** Returns a translated display name for the resource type. */
    val displayName: String
    private val mAlternateXmlNames: Array<out String>

    constructor(name: String, displayName: String, vararg alternateXmlNames: String) {
        this.xmlName = name
        mKind = Kind.REAL
        this.displayName = displayName
        mAlternateXmlNames = alternateXmlNames
    }

    constructor(name: String, displayName: String, kind: Kind) {
        this.xmlName = name
        mKind = kind
        this.displayName = displayName
        mAlternateXmlNames = emptyArray()
    }

    val hasInnerClass: Boolean
        /**
         * Returns true if the generated R class contains an inner class for this [ResourceType].
         */
        get() = mKind != Kind.SYNTHETIC

    val canBeReferenced: Boolean
        /**
         * Returns true if this [ResourceType] can be referenced using the [ResourceUrl] syntax:
         * `@typeName/resourceName`.
         */
        get() = mKind == Kind.REAL && this != ATTR

    override fun toString(): String {
        // Unfortunately we still have code that relies on toString() returning the aapt name.
        return xmlName
    }

    companion object {
        /** The set of all types of resources that can be referenced by other resources. */
        val REFERENCEABLE_TYPES: ImmutableSet<ResourceType>
        private val TAG_NAMES: ImmutableMap<String, ResourceType>
        private val CLASS_NAMES: ImmutableMap<String, ResourceType>

        init {
            val tagNames = ImmutableMap.builder<String, ResourceType>()
            tagNames.put(SdkConstants.TAG_DECLARE_STYLEABLE, STYLEABLE)
            tagNames.put(SdkConstants.TAG_PUBLIC, PUBLIC)
            tagNames.put(OVERLAYABLE.xmlName, OVERLAYABLE)
            tagNames.put(MACRO.xmlName, MACRO)
            val classNames = ImmutableMap.builder<String, ResourceType>()
            classNames.put(STYLEABLE.xmlName, STYLEABLE)
            classNames.put(AAPT.xmlName, AAPT)
            for (type in values()) {
                if (type.mKind != Kind.REAL || type == STYLEABLE) {
                    continue
                }
                classNames.put(type.xmlName, type)
                tagNames.put(type.xmlName, type)
                for (alternateName in type.mAlternateXmlNames) {
                    tagNames.put(alternateName, type)
                }
            }
            TAG_NAMES = tagNames.build()
            CLASS_NAMES = classNames.build()
            REFERENCEABLE_TYPES =
                Arrays.stream(values())
                    .filter { obj: ResourceType -> obj.canBeReferenced }
                    .collect(Sets.toImmutableEnumSet())
        }

        /**
         * Returns the enum by its name as it appears in the R class.
         *
         * @param className name of the inner class of the R class, e.g. "string" or "styleable".
         */
        fun fromClassName(className: String): ResourceType? {
            return CLASS_NAMES[className]
        }

        /**
         * Returns the enum by its name as it appears as a folder name under `res/`.
         *
         * @param folderName name of the inner class of the R class, e.g. "drawable" or "color".
         */
        fun fromFolderName(folderName: String): ResourceType? {
            return CLASS_NAMES[folderName]
        }

        /**
         * Returns the enum by its name as it appears in XML as a tag name.
         *
         * @param tagName name of the XML tag, e.g. "string" or "declare-styleable".
         */
        fun fromXmlTagName(tagName: String): ResourceType? {
            return TAG_NAMES[tagName]
        }

        /**
         * Returns the enum by its name as it appears in a [ResourceUrl] string.
         *
         * @param xmlValue value of the type attribute or the prefix of a [ResourceUrl], e.g.
         *   "string" or "array".
         */
        fun fromXmlValue(xmlValue: String): ResourceType? {
            if (xmlValue == SdkConstants.TAG_DECLARE_STYLEABLE || xmlValue == STYLEABLE.xmlName) {
                return null
            }
            if (xmlValue == SAMPLE_DATA.xmlName) {
                return SAMPLE_DATA
            }
            if (xmlValue == OVERLAYABLE.xmlName) {
                return OVERLAYABLE
            }
            return if (xmlValue == MACRO.xmlName) {
                MACRO
            } else CLASS_NAMES[xmlValue]
        }

        fun <T> fromXmlTag(
            tag: T,
            nameFunction: Function<T, String>,
            attributeFunction: BiFunction<T, String, String>
        ): ResourceType? {
            val tagName = nameFunction.apply(tag)
            return when (tagName) {
                SdkConstants.TAG_EAT_COMMENT -> null
                SdkConstants.TAG_ITEM -> {
                    val typeAttribute = attributeFunction.apply(tag, SdkConstants.ATTR_TYPE)
                    if (!Strings.isNullOrEmpty(typeAttribute)) {
                        fromClassName(typeAttribute)
                    } else {
                        null
                    }
                }
                else -> fromXmlTagName(tagName)
            }
        }

        fun fromXmlTag(domNode: Node): ResourceType? {
            if (domNode !is Element) {
                return null
            }
            return fromXmlTag(
                domNode,
                { element: Element -> MoreObjects.firstNonNull(element.localName, element.tagName) }
            ) { obj: Element, name: String? ->
                obj.getAttribute(name)
            }
        }

        @Deprecated(
            "Use other static methods in this class. Kept for layoutlib binary compatibility."
        )
        fun getEnum(className: String): ResourceType? {
            return fromClassName(className)
        }
    }
}
